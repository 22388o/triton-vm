# TIP 0001: Memory Consistency

| TIP | 0001 |
|-|-|
| authors: | Alan Szepieniec and Ferdinand Sauer |
| title: | Memory Consistency |
| status: | draft |
| created: | 2022-08-15 |
| issue tracker: |  |

**Abstract.** In the current specification, the memory-like tables `RamTable`, `JumpStackTable`, and `OpStackTable` do not satisfy memory-consistency. Specifically, they are vulnerable to [Yuncong's attack](https://github.com/TritonVM/triton-vm/issues/12), which exploits the unverified and thus possibly-incorrect sorting in these tables. This TIP addresses the issue by a) introducing a new table argument, the *contiguity argument* which establishes contiguity of the regions of fixed memory pointer; and b) by introducing a new table, the *clock jump table*, which in combination with a permutation argument establishes the correct sorting of rows by clock cycle within each contiguous region.

## Introduction

The memory tables `RamTable`, `JumpStackTable`, and `OpStackTable` should be sorted by memory pointer first, and by clock cycle second. When this correct sorting is not enforced, it gives rise to attack undermining memory-consistency.

[Part V](https://aszepieniec.github.io/stark-brainfuck/attack) of the [BrainSTARK tutorial](https://aszepieniec.github.io/stark-brainfuck/) shows that it memory-consistency follows if in the memory table every sublist of rows with the same memory pointer forms a contiguous region. The sorting rule is just one way to guarantee this contiguity. The sorting by clock cycle within each contiguous region is still necessary.

This TIP proposes two independent constructions to fix the arrangement issues. Put together, they imply memory-consistency for all three memory-like tables. The constructions are summarized as follows:

 - The *contiguity argument* is a collection of four extension columns and several extension AIR constraints. The first extension column is a running product similar to that of a conditioned permutation argument. The second extension column is the formal derivative of the first. The next two are Bezout coefficients. A consistency AIR constraint takes the weighted sum and equates it to one. It can only be satisfied if the greatest common divisor of the running product and its formal derivative is one â€“ implying that no change in the memory pointer resets it to a value used earlier.
 - The *Clock Jump Table* is a new table containing *clock jump*s. A *clock jump* is any difference of two or larger in the clock cycle in consecutive rows of a memory-like table where the memory pointer remains the same. By bounding the magnitude of these jumps one establishes correct sorting within contiguous regions. The Clock Jump Table contains at least every clock jump to occur in any memory-like table, in ascending order. A transition AIR constraint guarantees that the main column can grow by at most 1 per row, thereby bounding all elements in the table.

## Contiguity Argument

The contiguity argument is only needed for the Ram Table because the memory pointer there (`ramp`) can take any value. In contrast, the two other memory-like tables, OpStackTable and JumpStackTable are stacks and therefore naturally generate contiguous access patterns.

Since the contiguity argument may have applications elsewhere, it is presented here in a generic language.

Let `ramp` be the column whose contiguity we wish to establish. We add three extension columns: the difference inverse `di`, the running product `rp`, and the formal derivative `fd`. Additionally, the prover commits to two polynomials $a(X)$ and $b(X)$ but these polynomials do not correspond to columns in the table.

The values contained in these columns is undetermined until the verifier's challenge $\alpha$ is known; before that happens it is worthwhile to present the polynomial expressions in $X$, anticipating the substitution $X \mapsto \alpha$.

The difference inverse takes the inverse of the difference between the current and next `ramp` values. This constraint corresponds to two consistency constraint polynomials: $(\mathsf{ramp}^\star - \mathsf{ramp})\cdot((\mathsf{ramp}^\star - \mathsf{ramp}) \cdot \mathsf{di} - 1)$ and $\mathsf{di}\cdot((\mathsf{ramp}^\star - \mathsf{ramp}) \cdot \mathsf{di} - 1)$.

Let $g(X)$ and $h(X)$ be distinct uniformly random polynomials of degree at most 1. These polynomials will be used as initials to randomize the `rp` and `fd` columns. When zero-knowledge is not necessary, it cannot hurt to set $g(X) = 1$ and $h(X)=0$. Also note that since $h(X)$ does not need to be the formal derivative of $g(X)$, and if this is the case the name "formal derivative" for the column is note entirely accurate.

The running product starts with $g(X)$ initially and accumulates a factor $X - \mathsf{ramp}$ in every pair of rows where $\mathsf{ramp} \neq \mathsf{ramp}^\star$. This evolution corresponds one transition constraint: $(\mathsf{ramp}^\star - \mathsf{ramp}) \cdot (\mathsf{rp}^\star - \mathsf{rp} \cdot (X - \mathsf{ramp})) + (1 -(\mathsf{ramp}^\star -\mathsf{ramp}) \cdot \mathsf{di}) \cdot (\mathsf{rp}^\star - \mathsf{rp})$.

The formal derivative contains the "formal derivative" of the running product with respect to $X$ (up to the masking factors $g(X)$ and $h(X)$). The formal derivative is initially $h(X)$. The transition constraint applies the product rule of differentiation conditioned upon the difference in `ramp` being nonzero:  $(\mathsf{ramp}^\star - \mathsf{ramp}) \cdot (\mathsf{fd}^\star + \mathsf{rp} \cdot \mathsf{ramp}^\star - (X - \mathsf{ramp}) \cdot \mathsf{fd}) + (1 -(\mathsf{ramp}^\star -\mathsf{ramp}) \cdot \mathsf{di}) \cdot (\mathsf{fd}^\star - \mathsf{fd})$. To see why this rule is correct, observe that
$$ \frac{\mathsf{d}\, (X - \mathsf{ramp}^\star) \cdot \mathsf{rp}}{\mathsf{d} \, X} = (X - \mathsf{ramp}^\star) \cdot \frac{\mathsf{d} \, \mathsf{rp}}{\mathsf{d} \, X} + \frac{\mathsf{d} \,( X - \mathsf{ramp}^\star)}{\mathsf{d} \, X} \cdot \mathsf{rp} $$
$$ = (X - \mathsf{ramp}^\star) \cdot \mathsf{fd} - \mathsf{ramp}^\star \cdot \mathsf{rp} \enspace . $$

Let $f_{\mathsf{rp}}(X)$ and $f_{\mathsf{fd}}(X)$ be the polynomials that correspond to $\mathsf{rp}$ and $\mathsf{fd}$ in the last row. The polynomials $a(X)$ and $b(X)$ are the Bezout coefficients of the relation
$$ a(X) \cdot f_{\mathsf{rp}}(X) + b(X) \cdot f_{\mathsf{fd}}(X) = \gcd(f_{\mathsf{rp}}(X),f_{\mathsf{fd}}(X)) \enspace .$$
While the extended Euclidean algorithm guarantees that an $a(X)$ and $b(X)$ exist that have at most the same degree as $\mathsf{rp}$ and $\mathsf{fd}$ (assuming their gcd is 1), even a much looser degree bound suffices. For the sake of the analysis, set the degree bound on $a(X)$ and $b(X)$ to $T$, the height of the table.

When the verifier supplies $\alpha$, the prover responds with (among other things) the terminal values $T_{\mathsf{rp}} = f_{\mathsf{rp}}(\alpha)$ and $T_{\mathsf{fd}} = f_{\mathsf{fd}}(\alpha)$. The prover also supplies the Bezout coefficients $A = a(\alpha)$ and $B = b(\alpha)$. The verifier verifies the correct calculation of the terminals using the AIR, and the correct calculation of the Bezout coefficients using the DEEP technique: the prover adds $q_{a}(X) = \frac{a(X) - A}{X - \alpha}$ and $q_{b}(X) = \frac{b(X) - B}{X - \alpha}$ to the nonlinear combination, and the verifier verifies that it was added. The verifier additionally verifies that $A \cdot T_{\mathsf{rp}} + B \cdot T_{\mathsf{fd}} = 1$.

**Correctness.** If the table has no non-contiguous regions, then $f_{\mathsf{rp}}(X)$ and $f_{\mathsf{fd}}(X)$ share no factors such that $\gcd(f_{\mathsf{rp}}(X), f_{\mathsf{fd}}(X)) = 1$. The verifier's prove amounts to checking this polynomial identity in $X = \alpha$.

**Soundness.** If the table has at least one non-contiguous region, then $f_{\mathsf{rp}}(X)$ and $f_{\mathsf{fd}}(X)$ share at least one factor. As a result, no Bezout coefficients $a(X)$ and $b(X)$ can exist such that $a(X)\cdot f_{\mathsf{rp}}(X) + b(X) \cdot f_{\mathsf{fd}}(X) = 1$. The verifier therefore probes an inequality polynomials of degree at most $2T$. According to the Schwartz-Zippel lemma the false positive probability is $2T / |\mathbb{F}|$.

## Clock Jump Table

The Clock Jump Table revolves around one column, `jmp`. This column contains every clock jump that occurs in `RamTable`, `OpStackTable`, or `JumpStackTable`. 