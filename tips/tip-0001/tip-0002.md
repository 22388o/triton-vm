# TIP 0002: Contiguity Argument for Memory Consistency

| TIP            | 0002                                       |
|:---------------|:-------------------------------------------|
| authors:       | Alan Szepieniec                                  |
| title:         | Multi-Table Subset Argument for Memory Consistency |
| status:        | draft                                      |
| created:       | 2022-08-15                                 |
| issue tracker: |                                                                                          |

**Abstract.** In the current specification, the memory-like tables `RamTable`, `JumpStackTable`, and `OpStackTable` do not satisfy memory-consistency. Specifically, they are vulnerable to [Yuncong's attack](https://github.com/TritonVM/triton-vm/issues/12), which exploits the unverified and thus possibly-incorrect sorting in these tables. This TIP addresses one part of the issue by introducing a new table argument, the *multi-table subset argument*. It establishes that certain values in different tables have a matching representative in a given lookup table. Applied to the present context, this technique establishes that every clock jump is positive. This note is a companion to TIP-0001, which introduces an new argument to establish the contiguity of regions of constant memory pointer. Together, TIP-0001 and TIP-0002 fix the memory consistency issue.

## Introduction

How to establish that a clock jump is directed forward (as opposed to direct backward, which would indicate malicious behavior)? One strategy is to show that the *difference*, *i.e.*, the next clock cycle minus the current clock cycle, is itself a clock cycle. Recall that the Processor Table's clock cycles run from 0 to $T-1$. Therefore, valid differences belong to $\lbrace 2, ..., T-1 \rbrace$ and invalid ones to $\lbrace p - T + 1, ..., p - 2 \rbrace$.

Standard subset arguments can show that the clock jump differences are elements of the Processor Table's clock cycle column. However, it is cumbersome to repeat this argument for three separate tables.

I present here a Polynomial IOP / RAP hybrid argument for showing that all clock jump differences in all three memory-like tables live also in the Processor Table's `clk` column. It introduces one extension column in each of Ram Table, Jump Stack Table, and Op Stack Table; one base and one extension column in Processor Table; and three committed polynomials that do not correspond to any columns.

## Intuition

Let $f(X)$ denote the polynomial

$$ f(X) = \left( \prod_{\delta_r} (X - \delta_r) \right) \cdot \left( \prod_{\delta_o} (X - \delta_o) \right) \cdot \left( \prod_{\delta_j} (X - \delta_j) \right) $$

where the $\delta_r$, $\delta_o$, and $\delta_j$ denote the clock jump differences in the Ram Table, OpStack Table, and Jump Stack Table, respectively.

This polynomial can be (and is) evaluated in a scalar $\alpha$ supplied by the verifier through three running products. (All three running products use the same challenge $\alpha$.) However, it is additionally committed to. The point $\alpha$ is used to verify that the committed polynomial $[f(X)]$ does indeed correspond to the product of running product columns.

Expand the Processor Table with a new column `cji` ("clock jump indicator") which takes the value 1 if the `clk` value is also the value of some clock jump, and 0 otherwise. The extension column computes the value of the polynomial 

$$h(X) = \prod_\delta (X - \delta)$$

in some scalar $\beta$ supplied by the verifier, where $\delta$ ranges over the values of `clk` in indicated rows.

Note that the roots of $f(X)$ correspond to roots of $h(X)$. However, the roots occur with various multiplicities in $f(X)$ and with multiplicity 1 in $h(X)$. To harmonize the multiplicities, we need the formal derivative $f'(X)$ of $f(X)$ to cancel all the square factors. Specifically, let $g(X) = \gcd(f(X), f'(X))$ then $h(X) g(X) = f(X)$ and to establish the correct gcd relation we need Bézout coefficients $a(X)$ and $b(X)$ for the Bézout relation

$$ a(X) f(X) + b(X) f'(X) = g(X) . $$

